import zipfile
import re
import io
from collections import defaultdict
import math
import os
import sys

# --- CONFIGURATION ---
save_file_path = "E:/zDev/Saves/2211.03.07/2211.03.07.sav"
stellaris_user_dir = "E:/Users/inigma/Documents/Paradox Interactive/Stellaris"
stellaris_install_dir = "D:/Program Files (x86)/Steam/steamapps/common/Stellaris"

output_map_file = "continuum.txt"
output_initializer_file = "continuum_initializers.txt"

def get_stellaris_language(user_dir):
    settings_path = os.path.join(user_dir, 'settings.txt')
    try:
        with open(settings_path, 'r', encoding='utf-8') as f:
            match = re.search(r'language="(\w+)"', f.read())
            if match:
                language_key = match.group(1).lstrip('l_')
                print(f"Detected language: {language_key}")
                return language_key
    except Exception:
        print("Warning: Could not detect language. Defaulting to English.")
    return "english"

def load_localization_data(install_dir, language):
    localization_map = {}
    base_loc_path = os.path.join(install_dir, 'localisation', language)
    print(f"Searching for all localization files in: {base_loc_path}")
    if not os.path.isdir(base_loc_path): return {}
    loc_pattern = re.compile(r'([\w_.-]+):\d*\s*"(.*?)"')
    for root, _, files in os.walk(base_loc_path):
        for filename in files:
            if filename.endswith(f'l_{language}.yml'):
                file_path = os.path.join(root, filename)
                try:
                    with open(file_path, 'r', encoding='utf-8-sig') as f:
                        content = f.read()
                        matches = loc_pattern.findall(content)
                        for key, value in matches:
                            localization_map[key] = value
                except Exception as e:
                    print(f"Warning: Error reading file {file_path}: {e}")
    print(f"Loaded {len(localization_map)} localization keys.")
    return localization_map

def resolve_name(name_block_content, loc_data, star_count_context=None, parent_body_name=None):
    if not name_block_content: return "Unknown"
    key_match = re.search(r'^\s*key="([^"]+)"', name_block_content)
    if not key_match: return "Unknown"
    name_key = key_match.group(1)

    if name_key.startswith('$') and name_key.endswith('$'):
        name_key = name_key.strip('$')

    variables_content = _get_nested_block_content(name_block_content, r'variables\s*=\s*{')
    
    # 1. Handle special formats FIRST
    if (name_key.startswith("STAR_NAME_") or name_key.endswith("_NAME_FORMAT") or name_key.startswith("NEW_COLONY_NAME")) and variables_content:
        if name_key.startswith("STAR_NAME_") or name_key.startswith("NEW_COLONY_NAME"):
            name_value_block = _get_nested_block_content(variables_content, r'key="NAME"\s*value\s*=\s*{')
            if name_value_block:
                base_name = resolve_name(name_value_block, loc_data, star_count_context)
                if name_key.startswith("NEW_COLONY_NAME"): return f"{base_name} Prime"
                star_match = re.match(r'STAR_NAME_(\d)_OF_(\d)', name_key)
                if star_match and star_count_context is not None and star_count_context > 1:
                    num = int(star_match.group(1))
                    if 1 <= num <= 3: return f"{base_name} {('ABC')[num - 1]}"
                return base_name
            return "Unknown Star"

        if name_key == "PLANET_NAME_FORMAT":
            parent_value_block = _get_nested_block_content(variables_content, r'key="PARENT"\s*value\s*=\s*{')
            numeral_value_block = _get_nested_block_content(variables_content, r'key="NUMERAL"\s*value\s*=\s*{')
            if parent_value_block and numeral_value_block:
                parent_name_val = resolve_name(parent_value_block, loc_data, star_count_context)
                numeral_key_match = re.search(r'key="([^"]+)"', numeral_value_block)
                if numeral_key_match:
                    return f"{parent_name_val} {numeral_key_match.group(1)}"
            return "Unknown Planet"

        if name_key == "SUBPLANET_NAME_FORMAT":
            parent_value_block = _get_nested_block_content(variables_content, r'key="PARENT"\s*value\s*=\s*{')
            numeral_matches = re.findall(r'key="NUMERAL"\s*value\s*=\s*{\s*key="([^"]+)"', variables_content, re.DOTALL)
            if parent_value_block and numeral_matches:
                moon_base_name = resolve_name(parent_value_block, loc_data, star_count_context)
                moon_numeral = numeral_matches[-1]
                
                # --- FINAL UNIQUE MOON LOGIC ---
                if parent_body_name and moon_base_name != parent_body_name:
                    return moon_base_name # It's a unique name like Baloryz

                if re.search(r'\s+[IVXLC]+$', moon_base_name):
                    return f"{moon_base_name}{moon_numeral.lower()}"
                else:
                    return f"{moon_base_name} {moon_numeral}"
            return "Unknown Moon"
            
        if name_key == "ASTEROID_NAME_FORMAT":
            prefix, suffix = "",""
            prefix_val_block = _get_nested_block_content(variables_content, r'key="prefix"\s*value\s*=\s*{')
            if prefix_val_block:
                prefix_match = re.search(r'key="([^"]+)"', prefix_val_block)
                if prefix_match: prefix = prefix_match.group(1)
            suffix_val_block = _get_nested_block_content(variables_content, r'key="suffix"\s*value\s*=\s*{')
            if suffix_val_block:
                suffix_match = re.search(r'key="([^"]+)"', suffix_val_block)
                if suffix_match: suffix = suffix_match.group(1)
            return f"{prefix}{suffix}"

    # 2. If not a special format, check for a direct translation
    if name_key in loc_data:
        return loc_data[name_key]

    # 3. Final fallback with refined smart clean-up
    clean_name = re.sub(r'(_system|_SYSTEM)$', '', name_key)
    clean_name = re.sub(r'^(NAME_|SPEC_)', '', clean_name)
    return clean_name.replace('_', ' ')


def _get_nested_block_content(text, start_regex):
    match = re.search(start_regex, text)
    if not match: return None
    content_start_index = match.end()
    brace_level = 1
    for i in range(content_start_index, len(text)):
        char = text[i]
        if char == '{': brace_level += 1
        elif char == '}': brace_level -= 1
        if brace_level == 0: return text[content_start_index:i]
    return None

def build_galaxy_hierarchy(stars, planets, loc_data):
    moons_by_parent = defaultdict(list)
    for planet_id, planet_data in planets.items():
        if 'moon_of' in planet_data: moons_by_parent[planet_data['moon_of']].append(planet_data)
    hierarchical_systems = []
    for star_id, star_data in stars.items():
        system = star_data; system['planets'] = []
        system['system_star_class'] = system.get('star_class', 'sc_g')

        if 'raw_name_block' in star_data:
            system['name'] = resolve_name(star_data['raw_name_block'], loc_data)

        for planet_id in star_data.get('planet_ids', []):
            if planet_id in planets:
                planet_data = planets[planet_id]
                if 'moon_of' not in planet_data:
                    if 'x' in planet_data and 'y' in planet_data: planet_data['orbit'] = math.sqrt(float(planet_data['x'])**2 + float(planet_data['y'])**2)
                    elif 'orbit' in planet_data: planet_data['orbit'] = abs(float(planet_data['orbit']))
                    system['planets'].append(planet_data)
        def attach_moons_recursively(body_list):
            for body in body_list:
                if body.get('id') in moons_by_parent:
                    body['moons'] = sorted(moons_by_parent[body.get('id')], key=lambda m: float(m.get('orbit', 0)))
                    attach_moons_recursively(body['moons']) # Recursive call for sub-moons
        attach_moons_recursively(system['planets'])
        system['planets'].sort(key=lambda p: (
            0 if any(s in p.get('planet_class', '') for s in ['_star', 'hole', 'pulsar']) and float(p.get('orbit', 0)) == 0 else 2 if any(s in p.get('planet_class', '') for s in ['_star', 'hole', 'pulsar']) else 1,
            float(p.get('orbit', 0))
        ))
        star_count = sum(1 for p in system['planets'] if any(s in p.get('planet_class', '') for s in ['_star', 'hole', 'pulsar']))
        
        # --- REVISED: Now passes parent name context to moons ---
        def resolve_names_recursively(body_list, star_context):
            for body in body_list:
                if 'raw_name_block' in body:
                    body['name'] = resolve_name(body['raw_name_block'], loc_data, star_context)
                if 'moons' in body:
                    # Pass the parent body's resolved name when resolving moon names
                    for moon in body['moons']:
                        if 'raw_name_block' in moon:
                             moon['name'] = resolve_name(moon['raw_name_block'], loc_data, star_context, parent_body_name=body.get('name'))

        resolve_names_recursively(system['planets'], star_context=star_count)
        
        print(f"System {system.get('name', 'Unknown')}: Processed.")
        hierarchical_systems.append(system)
    return hierarchical_systems

def parse_block_content(block_text):
    data = {}
    name_block_content = _get_nested_block_content(block_text, r'name\s*=\s*{')
    if name_block_content: data['raw_name_block'] = name_block_content
    else:
        simple_name_match = re.search(r'^\s*name="([^"]+)"', block_text, re.MULTILINE)
        if simple_name_match: data['name'] = simple_name_match.group(1).replace('_', ' ')
    patterns = {'type': r'^\s*type=([\w_]+)', 'x': r'coordinate=\s*{[^}]*?x=([-\d\.]+)', 'y': r'coordinate=\s*{[^}]*?y=([-\d\.]+)', 'planet_class': r'^\s*planet_class="([^"]+)"', 'planet_size': r'^\s*planet_size=(\d+)', 'orbit': r'^\s*orbit=([-\d\.]+)', 'moon_of': r'^\s*moon_of=(\d+)', 'star_class': r'^\s*star_class="([^"]+)"'}
    for key, pattern in patterns.items():
        match = re.search(pattern, block_text, re.MULTILINE)
        if match: data[key] = match.group(1)
    data['hyperlanes'] = re.findall(r'^\s*to=(\d+)', block_text, re.MULTILINE)
    data['planet_ids'] = re.findall(r'^\s*planet=(\d+)', block_text, re.MULTILINE)
    return data

def parse_section(line_iterator, header_regex):
    objects = {}
    for line in line_iterator:
        if line.strip() == '}': return objects
        match = header_regex.match(line)
        if match:
            object_id = match.group(1)
            block_lines = [line]
            brace_level = line.count('{') - line.count('}')
            if brace_level <= 0 and '{' in line:
                objects[object_id] = {'id': object_id, **parse_block_content("".join(block_lines))}; continue
            for block_line in line_iterator:
                block_lines.append(block_line)
                brace_level += block_line.count('{'); brace_level -= block_line.count('}')
                if brace_level <= 0: break
            objects[object_id] = {'id': object_id, **parse_block_content("".join(block_lines))}
    return objects

def parse_stellaris_save(path):
    stars, planets, counts = {}, {}, defaultdict(int)
    try:
        with zipfile.ZipFile(path, 'r') as save_zip:
            if 'gamestate' not in save_zip.namelist(): return None, None, counts
            with save_zip.open('gamestate') as gamestate_file:
                line_iterator = io.TextIOWrapper(gamestate_file, encoding='utf-8')
                star_header_re, planet_header_re = re.compile(r'^\t(\d+)=') , re.compile(r'^\t\t(\d+)=')
                for line in line_iterator:
                    stripped_line = line.strip()
                    if stripped_line == 'galactic_object=': next(line_iterator); stars = parse_section(line_iterator, star_header_re)
                    elif stripped_line == 'planets=': next(line_iterator); next(line_iterator); planets = parse_section(line_iterator, planet_header_re)
    except Exception as e:
        print(f"An error occurred during save file parsing: {e}"); return None, None, counts
    for _, planet_data in planets.items():
        p_class = planet_data.get('planet_class', '')
        if any(s in p_class for s in ['_star', 'hole', 'pulsar']): counts['star'] += 1
        elif p_class == "pc_asteroid": counts['asteroid'] += 1
        elif 'moon_of' in planet_data: counts['moon'] += 1
        else: counts['planet'] += 1
    return stars, planets, counts

def write_map_file_with_initializers(systems_list, start_system_id, output_path):
    if not systems_list: return
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('static_galaxy_scenario = {\n')
        f.write('\tname = "Continuum"\n\tpriority = 200\n\tsupports_shape = elliptical\n\n')
        f.write('\tnum_empires = { min = 1 max = 1 }\n\tnum_empire_default = 1\n\n')
        f.write('\trandom_hyperlanes = no\n\tcore_radius = 0\n\n')
        f.write('\t# --- System Definitions ---\n')
        for system in systems_list:
            sys_id, sys_name = system.get('id'), system.get('name', f"Sys_{system.get('id')}").replace('"', '')
            sys_x, sys_y = system.get('x', '0'), system.get('y', '0')
            initializer_name = f"continuum_system_init_{sys_id}"
            f.write(f'\tsystem = {{ id = "{sys_id}" name = "{sys_name}" position = {{ x = {sys_x} y = {sys_y} }} initializer = {initializer_name} }}\n')
        f.write('\n\t# --- Hyperlane Definitions ---\n')
        processed_lanes, systems_dict = set(), {s['id']: s for s in systems_list}
        for system_id, system_data in systems_dict.items():
            for target_id in system_data.get('hyperlanes', []):
                if target_id in systems_dict:
                    lane_key = tuple(sorted((system_id, target_id)))
                    if lane_key not in processed_lanes:
                        f.write(f'\tadd_hyperlane = {{ from = "{system_id}" to = "{target_id}" }}\n')
                        processed_lanes.add(lane_key)
        f.write('}\n')
def write_initializer_file(systems_list, start_system_id, output_path):
    if not systems_list: return
    with open(output_path, 'w', encoding='utf-8') as f:
        def write_moons_recursively(moons_list, indent_level):
            last_moon_orbit = 0.0
            tabs = '\t' * indent_level
            for moon in moons_list:
                absolute_orbit = float(moon.get("orbit", 10))
                relative_orbit = absolute_orbit - last_moon_orbit
                f.write(f'{tabs}moon = {{\n')
                if "name" in moon:
                    moon_name = moon["name"].replace('"', '')
                    f.write(f'{tabs}\tname = "{moon_name}"\n')
                f.write(f'{tabs}\tclass = "{moon.get("planet_class", "pc_barren_cold")}"\n')
                f.write(f'{tabs}\tsize = {moon.get("planet_size", 5)}\n')
                f.write(f'{tabs}\torbit_distance = {relative_orbit:.2f}\n')
                if 'moons' in moon and moon['moons']: write_moons_recursively(moon['moons'], indent_level + 1)
                f.write(f'{tabs}}}\n')
                last_moon_orbit = absolute_orbit
        for system in systems_list:
            sys_id, sys_name = system.get('id'), system.get('name', f"Sys_{system.get('id')}").replace('"', '')
            initializer_name, star_class = f"continuum_system_init_{sys_id}", system.get('system_star_class', 'sc_g')
            f.write(f"{initializer_name} = {{\n")
            f.write(f'\tname = "{sys_name}"\n\tclass = "{star_class}"\n')
            f.write('\tusage = empire_init\n\n' if sys_id == start_system_id else '\tusage = misc_system_init\n\n')
            last_absolute_orbit, is_first_planet = 0.0, True
            if 'planets' in system and system['planets']:
                for planet in system['planets']:
                    absolute_orbit = float(planet.get("orbit", 50))
                    relative_orbit = absolute_orbit - last_absolute_orbit
                    f.write(f'\tplanet = {{\n')
                    if "name" in planet:
                        planet_name = planet["name"].replace('"', '')
                        if not planet_name.startswith("NEW COLONY"): f.write(f'\t\tname = "{planet_name}"\n')
                    p_class = planet.get("planet_class", "pc_barren")
                    f.write(f'\t\tclass = "{p_class}"\n\t\tsize = {planet.get("planet_size", 10)}\n')
                    f.write(f'\t\torbit_distance = {relative_orbit:.2f}\n')
                    if sys_id == start_system_id and is_first_planet and not any(s in p_class for s in ['_star', 'hole', 'pulsar']):
                        f.write('\t\thome_planet = yes\n')
                        is_first_planet = False
                    if 'moons' in planet and planet['moons']: write_moons_recursively(planet['moons'], 2)
                    f.write(f'\t}}\n\n')
                    last_absolute_orbit = absolute_orbit
            f.write(f"}}\n\n")

if __name__ == "__main__":
    for path in [save_file_path, stellaris_user_dir, stellaris_install_dir]:
        if not os.path.exists(path):
            print(f"FATAL ERROR: Path not found: '{path}'. Please check your configuration.")
            sys.exit(1)
    game_language = get_stellaris_language(stellaris_user_dir)
    localization = load_localization_data(stellaris_install_dir, game_language)
    if not localization:
        print("FATAL ERROR: No localization data loaded. Check game paths and language settings.")
        sys.exit(1)
    parsed_stars, parsed_planets, counts = parse_stellaris_save(save_file_path)
    if parsed_stars and parsed_planets:
        galaxy_data = build_galaxy_hierarchy(parsed_stars, parsed_planets, localization)
        system_count = len(galaxy_data)
        start_system_id = None
        for system in galaxy_data:
            if system.get('name', '').lower() == 'sol':
                start_system_id = system.get('id'); break
        if not start_system_id and galaxy_data:
            start_system_id = galaxy_data[0].get('id')
        write_map_file_with_initializers(galaxy_data, start_system_id, output_map_file)
        write_initializer_file(galaxy_data, start_system_id, output_initializer_file)
        print("\n--- PARSING COMPLETE ---")
        print(f"Found {system_count} systems, {counts['star']} stars, {counts['planet']} planets, {counts['moon']} moons, and {counts['asteroid']} asteroids.")
        print(f"Output files '{output_map_file}' and '{output_initializer_file}' have been generated.")